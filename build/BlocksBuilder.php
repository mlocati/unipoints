<?php

declare(strict_types=1);

namespace MLUnipoints\Build;

use MLUnipoints\Info\PlaneInfo;
use MLUnipoints\Plane;
use RuntimeException;

/**
 * @see https://www.unicode.org/reports/tr44/#Blocks.txt
 */
class BlocksBuilder
{
    private readonly DataStorage $dataStorage;

    /**
     * @var \MLUnipoints\Build\BlocksBuilder\Block[]|null
     */
    private ?array $blocks = null;

    public function __construct(
        public readonly string $unicodeVersion,
        ?DataStorage $dataStorage = null,
    ) {
        $this->dataStorage = $dataStorage ?? DataStorage::getInstance();
    }

    /**
     * @return \MLUnipoints\Build\BlocksBuilder\Block[]
     */
    public function getBlocks(): array
    {
        return $this->blocks ??= $this->createBlocks();
    }

    public function getBlockForCodepoint(int $codepoint): ?BlocksBuilder\Block
    {
        foreach ($this->getBlocks() as $block) {
            if ($block->fromCodepoint <= $codepoint && $codepoint <= $block->toCodepoint) {
                return $block;
            }
        }

        return null;
    }

    public function saveBlocks(string $filename = '', ?string $namespace = null): void
    {
        $code = $this->createPHPCode($namespace);
        if ($filename === '') {
            $filename = str_replace(DIRECTORY_SEPARATOR, '/', realpath(__DIR__ . '/../src')) . '/Block.php';
        }
        if (file_put_contents($filename, $code) !== strlen($code)) {
            throw new RuntimeException("Failed to save blocks to file {$filename}");
        }
    }

    /**
     * @return \MLUnipoints\Build\BlocksBuilder\Block[]
     */
    protected function createBlocks(): array
    {
        $result = [];
        foreach ($this->dataStorage->readBlocks($this->unicodeVersion) as $line) {
            $result[] = $this->createBlock($line);
        }

        return $result;
    }

    protected function createBlock(string $line): BlocksBuilder\Block
    {
        $match = null;
        if (!preg_match('/^(?<from>[0-9A-F]+)\s*\.\.\s*(?<to>[0-9A-F]+)\s*;\s*(?<name>\S.*)$/i', $line, $match)) {
            throw new RuntimeException("Malformed line in Blocks.txt:\n{$line}");
        }
        $fromCodepoint = hexdec($match['from']);
        $toCodepoint = hexdec($match['to']);
        $name = $match['name'];
        if ($fromCodepoint < 0 || $fromCodepoint > $toCodepoint) {
            throw new RuntimeException("The block {$name} has wrong ranges!");
        }
        foreach (Plane::cases() as $plane) {
            $info = PlaneInfo::from($plane);
            if ($info->fromCodepoint <= $fromCodepoint && $fromCodepoint <= $info->toCodepoint) {
                if ($toCodepoint > $info->toCodepoint) {
                    throw new RuntimeException("The block {$name} spawns across multiple planes!");
                }
                return new BlocksBuilder\Block(
                    fromCodepoint: $fromCodepoint,
                    toCodepoint: $toCodepoint,
                    name: $name,
                    plane: $plane,
                );
            }
        }
        throw new RuntimeException("There's no plane for the block {$name}!");
    }

    protected function createPHPCode(?string $namespace = null, bool $withOpeningTag = true): string
    {
        if ($namespace === null) {
            $namespace = 'MLUnipoints';
        } else {
            $namespace = trim($namespace, '\\');
        }
        $myClass = get_class($this);
        if ($withOpeningTag) {
            $result = "<?php\n\n";
        } else {
            $result = '';
        }
        $result .= <<<EOT
/*
 * Please DO NOT edit this file manually!
 * It has been generated automatically by {$myClass}
 */

declare(strict_types=1);

EOT
        ;
        if ($namespace !== '') {
            $result .= "\nnamespace {$namespace};\n\n";
        }
        $unicodeVersion = var_export($this->unicodeVersion, true);
        $result .= <<<EOT
use MLUnipoints\Info\BlockInfo;
use MLUnipoints\Info\UnicodeInfo;

#[UnicodeInfo(unicodeVersion: {$unicodeVersion})]
enum Block
{

EOT
        ;
        $previousBlock = null;
        foreach ($this->getBlocks() as $block) {
            $result .= $this->createPHPCodeForBlock($block, $previousBlock);
            $previousBlock = $block;
        }
        $result .= "}\n";

        return str_replace("\r\n", "\n", $result);
    }

    protected function createPHPCodeForBlock(BlocksBuilder\Block $block, ?BlocksBuilder\Block $previousBlock): string
    {
        $indent = str_repeat(str_repeat(' ', 4), 1);
        $lines = [];
        if ($previousBlock !== null) {
            $lines[] = '';
        }
        if ($previousBlock === null || $previousBlock->plane !== $block->plane) {
            $planeInfo = PlaneInfo::from($block->plane);
            $lines[] = "{$indent}// Blocks for plane {$block->plane->value} ({$planeInfo->name}}";
            $lines[] = '';
        }
        $fromCodepoint = '0x' . strtoupper(dechex($block->fromCodepoint));
        $toCodepoint = '0x' . strtoupper(dechex($block->toCodepoint));
        $name = var_export($block->name, true);
        $lines[] = "{$indent}#[BlockInfo(fromCodepoint: {$fromCodepoint}, toCodepoint: {$toCodepoint}, name: {$name}, plane: Plane::{$block->plane->name})]";
        $lines[] = "{$indent}case {$block->codename};";

        return implode("\n", $lines) . "\n";
    }
}
